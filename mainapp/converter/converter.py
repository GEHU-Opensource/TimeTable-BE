import csv
import io
import json
import os
from datetime import datetime
from openpyxl import Workbook


def csv_to_json(file):
    file.seek(0)  # Ensure the file pointer is at the beginning
    reader = list(csv.reader(io.StringIO(file.read().decode("utf-8"))))

    # Identify the starting row for timetable data
    start_index = None
    for i, row in enumerate(reader):
        if row and "DAY" in row[0].upper():
            start_index = i
            break

    if start_index is None:
        return json.dumps({"error": "No valid timetable structure found"}, indent=2)

    reader = reader[start_index:]  # Skip metadata rows
    time_slots = [slot.strip() for slot in reader[0][1:] if slot.strip()]
    timetable = {}

    weekdays = {
        "MONDAY",
        "TUESDAY",
        "WEDNESDAY",
        "THURSDAY",
        "FRIDAY",
    }

    for i in range(
        1, len(reader), 2
    ):  # Iterate two rows at a time (subjects and teachers)
        if i + 1 < len(reader):  # Ensure the next row exists
            day = reader[i][0].strip().upper()
            if day not in weekdays:
                continue  # Skip rows that are not part of the main weekday schedule

            timetable[day] = []  # Initialize list for day's classes
            subjects = [
                cell.split("(")[0].strip()
                for cell in reader[i][1 : len(time_slots) + 1]
            ]  # Remove extra mapping info
            teachers = reader[i + 1][1 : len(time_slots) + 1]

            for j, subject in enumerate(subjects):
                subject = subject.strip()
                if subject and subject not in ["BREAK", "LUNCH", ""]:
                    timetable[day].append(
                        {
                            "teacher_id": (
                                teachers[j].strip()
                                if j < len(teachers) and teachers[j]
                                else "Unknown"
                            ),
                            "subject_id": subject,
                            "time_slot": time_slots[j],
                        }
                    )

    return json.dumps(timetable, indent=2)


def extract_time_slots_for_teacher(timetable, time_slot_order):
    """Extract and sort time slots dynamically based on backend input."""
    unique_slots = {entry["time_slot"] for day_data in timetable.values() for slots in day_data.values() for entry in slots}
    sorted_slots = sorted(unique_slots, key=lambda slot: time_slot_order.get(slot, float('inf')))
    return [("CLASS", slot) for slot in sorted_slots]

def teacher_json_to_csv(teacher_timetable, output_folder, time_slots):
    """Convert teacher timetable dictionary to CSV with dynamic time slots."""
    os.makedirs(output_folder, exist_ok=True)
    time_slot_order = {v: k for k, v in time_slots.items()}
    days_of_week_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday","Saturday"]

    for teacher_id, schedule in teacher_timetable.items():
        final_slots = extract_time_slots_for_teacher(schedule, time_slot_order)
        csv_file = os.path.join(output_folder, f"{teacher_id}.csv")
        header = ["DAY"] + [slot[1] for slot in final_slots]
        rows = []

        sorted_days = sorted(schedule.items(), key=lambda x: days_of_week_order.index(x[0]))

        for day, day_data in sorted_days:
            row = [day] + ["" for _ in final_slots]
            
            for section, classes in day_data.items():
                for entry in classes:
                    for i, slot in enumerate(final_slots):
                        if entry["time_slot"] == slot[1]:
                            row[i + 1] = f"{entry['subject_id']} ({section}, {entry['classroom_id']})"
            
            rows.append(row)

        with open(csv_file, mode="w", newline="", encoding="utf-8") as file:
            writer = csv.writer(file)
            writer.writerow(header)
            writer.writerows(rows)


def extract_time_slots_for_classroom(timetable, time_slot_order):
    """Extract and sort time slots from the timetable based on a predefined order."""
    unique_slots = set()
  
    # Collect all unique time slots
    for day_data in timetable.values():
        for slots in day_data.values():
            for entry in slots:
                if isinstance(entry, dict) and "time_slot" in entry:
                    unique_slots.add(entry["time_slot"])
                else:
                    print(f"ERROR: Unexpected entry format -> {entry}")

    sorted_slots = sorted(unique_slots, key=lambda slot: time_slot_order.get(slot, float('inf')))
    
    return [("CLASS", slot) for slot in sorted_slots]

def classroom_json_to_csv(classroom_timetable, output_folder, time_slots):
    """Convert classroom timetable JSON to CSV."""
    os.makedirs(output_folder, exist_ok=True)  # Ensure output folder exists
    time_slot_order = {v: k for k, v in time_slots.items()}
    days_of_week_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]

    for classroom_id, schedule in classroom_timetable.items():
        final_slots = extract_time_slots_for_classroom(schedule, time_slot_order)
        csv_file = os.path.join(output_folder, f"{classroom_id}.csv")
        header = ["DAY"] + [slot[1] for slot in final_slots]
        rows = []

        # Sort days correctly
        sorted_days = sorted(schedule.items(), key=lambda x: days_of_week_order.index(x[0]) if x[0] in days_of_week_order else float('inf'))

        for day, day_data in sorted_days:
            row = [day] + ["" for _ in final_slots]  # Empty slots initially
            
            for section, classes in day_data.items():
                for entry in classes:
                    for i, slot in enumerate(final_slots):
                        if entry["time_slot"] == slot[1]:
                            row[i + 1] = f"{entry['subject_id']} ({section}, {entry['teacher_id']})"
            
            rows.append(row)

        # Write to CSV
        with open(csv_file, mode="w", newline="", encoding="utf-8") as file:
            writer = csv.writer(file)
            writer.writerow(header)
            writer.writerows(rows)  


def parse_time(time_slot):
    """Extract start and end times from a time slot string."""
    start_time_str, end_time_str = time_slot.split(" - ")
    start_time = datetime.strptime(start_time_str.strip(), "%I:%M").time()
    end_time = datetime.strptime(end_time_str.strip(), "%I:%M").time()
    return start_time, end_time

def extract_time_slots(timetable,time_slot_order):
    """Extract, sort time slots, and insert BREAK/LUNCH where needed."""
    unique_slots = set()

    # Collect all unique time slots from timetable
    for day_data in timetable.values():
        for slots in day_data.values():
            for entry in slots:
                unique_slots.add(entry["time_slot"])

    # Sort slots based on predefined order
    sorted_slots = sorted(unique_slots, key=lambda slot: time_slot_order[slot])

    # Insert BREAK and LUNCH dynamically based on gaps
    final_slots = []
    last_end_time = None
    break_lunch_counter = 0

    for slot in sorted_slots:
        start_time, end_time = parse_time(slot)

        if last_end_time:
            gap = (datetime.combine(datetime.today(), start_time) - datetime.combine(datetime.today(), last_end_time)).seconds / 60

            if gap > 5:  # If there's a gap greater than 5 minutes
                break_time = f"{last_end_time.strftime('%I:%M')} - {start_time.strftime('%I:%M')}"
                if break_lunch_counter == 0:
                    final_slots.append(("BREAK", break_time))
                elif break_lunch_counter == 1:
                    final_slots.append(("LUNCH", break_time))
                else:
                    final_slots.append(("BREAK", break_time))

                break_lunch_counter += 1  # Increment counter

        final_slots.append(("CLASS", slot))
        last_end_time = end_time  # Update last_end_time

    return final_slots

def json_to_csv(input_folder, json_filename, output_folder,time_slots):
    """Convert JSON timetable to CSV with breaks and lunches inserted."""
    # Reverse lookup to get slot number from time string
    time_slot_order = {v: k for k, v in time_slots.items()}

# List of days in the order we want them to appear
    days_of_week_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    json_file = os.path.join(input_folder, json_filename)

    with open(json_file, "r", encoding="utf-8") as file:
        timetable = json.load(file)

    sections = set()
    final_slots = extract_time_slots(timetable,time_slot_order)

    os.makedirs(output_folder, exist_ok=True)

    # Identify all sections
    for day_data in timetable.values():
        for section in day_data.keys():
            sections.add(section)

    # Sort days in the correct order
    sorted_days = sorted(timetable.items(), key=lambda x: days_of_week_order.index(x[0]))

    for section in sections:
        csv_file = os.path.join(output_folder, f"{section}.csv")
        header = ["DAY"] + [slot[1] for slot in final_slots]  # Extract only time for header
        rows = []

        # Iterate over sorted days in the correct order
        for day, day_data in sorted_days:  # Sorted days based on days_of_week_order
            # Initialize row with blank spaces
            row = [day] + [""] * len(final_slots)  # Initially empty for each time slot

            if section in day_data:
                for entry in day_data[section]:
                    for i, slot in enumerate(final_slots):
                        # Compare and add the class schedule, BREAK, or LUNCH
                        if entry["time_slot"] == slot[1] and slot[0] == "CLASS":
                            row[i + 1] = f"{entry['subject_id']} ({entry['teacher_id']}, {entry['classroom_id']})"
                        elif slot[0] == "BREAK" or slot[0] == "LUNCH":
                            # Add BREAK and LUNCH to appropriate slots
                            row[i + 1] = slot[0]

            rows.append(row)

        # Write the row into CSV
        with open(csv_file, mode="w", newline="", encoding="utf-8") as file:
            writer = csv.writer(file)
            writer.writerow(header)
            writer.writerows(rows)

        print(f"CSV file '{csv_file}' has been created successfully!")


def merge_section_csvs_to_excel(department, course_id, total_sections, output_dir="static/csvs"):
    wb = Workbook()
    first = True

    for sec in total_sections:
        file_name = f"{department}-{course_id}-{sec}.csv"
        file_path = os.path.join(output_dir, file_name)

        if os.path.exists(file_path):
            sheet_name = f"Section-{sec}"
            ws = wb.active if first else wb.create_sheet(title=sheet_name)
            if first:
                ws.title = sheet_name
                first = False

            with open(file_path, newline='') as csvfile:
                reader = csv.reader(csvfile)
                for row in reader:
                    ws.append(row)

    merged_file_name = f"{department}-{course_id}-merged.xlsx"
    merged_path = os.path.join(output_dir, merged_file_name)
    wb.save(merged_path)
    return merged_file_name